// Code generated by MockGen. DO NOT EDIT.
// Source: ./service/interpreter/interfaces/interfaces.go

// Package interfaces is a generated GoMock package.
package interfaces

import (
	context "context"
	reflect "reflect"
	time "time"

	gomock "github.com/golang/mock/gomock"
	iwfidl "github.com/indeedeng/iwf/gen/iwfidl"
	service "github.com/indeedeng/iwf/service"
)

// MockActivityProvider is a mock of ActivityProvider interface.
type MockActivityProvider struct {
	ctrl     *gomock.Controller
	recorder *MockActivityProviderMockRecorder
}

// MockActivityProviderMockRecorder is the mock recorder for MockActivityProvider.
type MockActivityProviderMockRecorder struct {
	mock *MockActivityProvider
}

// NewMockActivityProvider creates a new mock instance.
func NewMockActivityProvider(ctrl *gomock.Controller) *MockActivityProvider {
	mock := &MockActivityProvider{ctrl: ctrl}
	mock.recorder = &MockActivityProviderMockRecorder{mock}
	return mock
}

// EXPECT returns an object that allows the caller to indicate expected use.
func (m *MockActivityProvider) EXPECT() *MockActivityProviderMockRecorder {
	return m.recorder
}

// GetActivityInfo mocks base method.
func (m *MockActivityProvider) GetActivityInfo(ctx context.Context) ActivityInfo {
	m.ctrl.T.Helper()
	ret := m.ctrl.Call(m, "GetActivityInfo", ctx)
	ret0, _ := ret[0].(ActivityInfo)
	return ret0
}

// GetActivityInfo indicates an expected call of GetActivityInfo.
func (mr *MockActivityProviderMockRecorder) GetActivityInfo(ctx interface{}) *gomock.Call {
	mr.mock.ctrl.T.Helper()
	return mr.mock.ctrl.RecordCallWithMethodType(mr.mock, "GetActivityInfo", reflect.TypeOf((*MockActivityProvider)(nil).GetActivityInfo), ctx)
}

// GetLogger mocks base method.
func (m *MockActivityProvider) GetLogger(ctx context.Context) UnifiedLogger {
	m.ctrl.T.Helper()
	ret := m.ctrl.Call(m, "GetLogger", ctx)
	ret0, _ := ret[0].(UnifiedLogger)
	return ret0
}

// GetLogger indicates an expected call of GetLogger.
func (mr *MockActivityProviderMockRecorder) GetLogger(ctx interface{}) *gomock.Call {
	mr.mock.ctrl.T.Helper()
	return mr.mock.ctrl.RecordCallWithMethodType(mr.mock, "GetLogger", reflect.TypeOf((*MockActivityProvider)(nil).GetLogger), ctx)
}

// NewApplicationError mocks base method.
func (m *MockActivityProvider) NewApplicationError(errType string, details interface{}) error {
	m.ctrl.T.Helper()
	ret := m.ctrl.Call(m, "NewApplicationError", errType, details)
	ret0, _ := ret[0].(error)
	return ret0
}

// NewApplicationError indicates an expected call of NewApplicationError.
func (mr *MockActivityProviderMockRecorder) NewApplicationError(errType, details interface{}) *gomock.Call {
	mr.mock.ctrl.T.Helper()
	return mr.mock.ctrl.RecordCallWithMethodType(mr.mock, "NewApplicationError", reflect.TypeOf((*MockActivityProvider)(nil).NewApplicationError), errType, details)
}

// RecordHeartbeat mocks base method.
func (m *MockActivityProvider) RecordHeartbeat(ctx context.Context, details ...interface{}) {
	m.ctrl.T.Helper()
	varargs := []interface{}{ctx}
	for _, a := range details {
		varargs = append(varargs, a)
	}
	m.ctrl.Call(m, "RecordHeartbeat", varargs...)
}

// RecordHeartbeat indicates an expected call of RecordHeartbeat.
func (mr *MockActivityProviderMockRecorder) RecordHeartbeat(ctx interface{}, details ...interface{}) *gomock.Call {
	mr.mock.ctrl.T.Helper()
	varargs := append([]interface{}{ctx}, details...)
	return mr.mock.ctrl.RecordCallWithMethodType(mr.mock, "RecordHeartbeat", reflect.TypeOf((*MockActivityProvider)(nil).RecordHeartbeat), varargs...)
}

// MockUnifiedLogger is a mock of UnifiedLogger interface.
type MockUnifiedLogger struct {
	ctrl     *gomock.Controller
	recorder *MockUnifiedLoggerMockRecorder
}

// MockUnifiedLoggerMockRecorder is the mock recorder for MockUnifiedLogger.
type MockUnifiedLoggerMockRecorder struct {
	mock *MockUnifiedLogger
}

// NewMockUnifiedLogger creates a new mock instance.
func NewMockUnifiedLogger(ctrl *gomock.Controller) *MockUnifiedLogger {
	mock := &MockUnifiedLogger{ctrl: ctrl}
	mock.recorder = &MockUnifiedLoggerMockRecorder{mock}
	return mock
}

// EXPECT returns an object that allows the caller to indicate expected use.
func (m *MockUnifiedLogger) EXPECT() *MockUnifiedLoggerMockRecorder {
	return m.recorder
}

// Debug mocks base method.
func (m *MockUnifiedLogger) Debug(msg string, keyvals ...interface{}) {
	m.ctrl.T.Helper()
	varargs := []interface{}{msg}
	for _, a := range keyvals {
		varargs = append(varargs, a)
	}
	m.ctrl.Call(m, "Debug", varargs...)
}

// Debug indicates an expected call of Debug.
func (mr *MockUnifiedLoggerMockRecorder) Debug(msg interface{}, keyvals ...interface{}) *gomock.Call {
	mr.mock.ctrl.T.Helper()
	varargs := append([]interface{}{msg}, keyvals...)
	return mr.mock.ctrl.RecordCallWithMethodType(mr.mock, "Debug", reflect.TypeOf((*MockUnifiedLogger)(nil).Debug), varargs...)
}

// Error mocks base method.
func (m *MockUnifiedLogger) Error(msg string, keyvals ...interface{}) {
	m.ctrl.T.Helper()
	varargs := []interface{}{msg}
	for _, a := range keyvals {
		varargs = append(varargs, a)
	}
	m.ctrl.Call(m, "Error", varargs...)
}

// Error indicates an expected call of Error.
func (mr *MockUnifiedLoggerMockRecorder) Error(msg interface{}, keyvals ...interface{}) *gomock.Call {
	mr.mock.ctrl.T.Helper()
	varargs := append([]interface{}{msg}, keyvals...)
	return mr.mock.ctrl.RecordCallWithMethodType(mr.mock, "Error", reflect.TypeOf((*MockUnifiedLogger)(nil).Error), varargs...)
}

// Info mocks base method.
func (m *MockUnifiedLogger) Info(msg string, keyvals ...interface{}) {
	m.ctrl.T.Helper()
	varargs := []interface{}{msg}
	for _, a := range keyvals {
		varargs = append(varargs, a)
	}
	m.ctrl.Call(m, "Info", varargs...)
}

// Info indicates an expected call of Info.
func (mr *MockUnifiedLoggerMockRecorder) Info(msg interface{}, keyvals ...interface{}) *gomock.Call {
	mr.mock.ctrl.T.Helper()
	varargs := append([]interface{}{msg}, keyvals...)
	return mr.mock.ctrl.RecordCallWithMethodType(mr.mock, "Info", reflect.TypeOf((*MockUnifiedLogger)(nil).Info), varargs...)
}

// Warn mocks base method.
func (m *MockUnifiedLogger) Warn(msg string, keyvals ...interface{}) {
	m.ctrl.T.Helper()
	varargs := []interface{}{msg}
	for _, a := range keyvals {
		varargs = append(varargs, a)
	}
	m.ctrl.Call(m, "Warn", varargs...)
}

// Warn indicates an expected call of Warn.
func (mr *MockUnifiedLoggerMockRecorder) Warn(msg interface{}, keyvals ...interface{}) *gomock.Call {
	mr.mock.ctrl.T.Helper()
	varargs := append([]interface{}{msg}, keyvals...)
	return mr.mock.ctrl.RecordCallWithMethodType(mr.mock, "Warn", reflect.TypeOf((*MockUnifiedLogger)(nil).Warn), varargs...)
}

// MockUnifiedContext is a mock of UnifiedContext interface.
type MockUnifiedContext struct {
	ctrl     *gomock.Controller
	recorder *MockUnifiedContextMockRecorder
}

// MockUnifiedContextMockRecorder is the mock recorder for MockUnifiedContext.
type MockUnifiedContextMockRecorder struct {
	mock *MockUnifiedContext
}

// NewMockUnifiedContext creates a new mock instance.
func NewMockUnifiedContext(ctrl *gomock.Controller) *MockUnifiedContext {
	mock := &MockUnifiedContext{ctrl: ctrl}
	mock.recorder = &MockUnifiedContextMockRecorder{mock}
	return mock
}

// EXPECT returns an object that allows the caller to indicate expected use.
func (m *MockUnifiedContext) EXPECT() *MockUnifiedContextMockRecorder {
	return m.recorder
}

// GetContext mocks base method.
func (m *MockUnifiedContext) GetContext() interface{} {
	m.ctrl.T.Helper()
	ret := m.ctrl.Call(m, "GetContext")
	ret0, _ := ret[0].(interface{})
	return ret0
}

// GetContext indicates an expected call of GetContext.
func (mr *MockUnifiedContextMockRecorder) GetContext() *gomock.Call {
	mr.mock.ctrl.T.Helper()
	return mr.mock.ctrl.RecordCallWithMethodType(mr.mock, "GetContext", reflect.TypeOf((*MockUnifiedContext)(nil).GetContext))
}

// MockTimerProcessor is a mock of TimerProcessor interface.
type MockTimerProcessor struct {
	ctrl     *gomock.Controller
	recorder *MockTimerProcessorMockRecorder
}

// MockTimerProcessorMockRecorder is the mock recorder for MockTimerProcessor.
type MockTimerProcessorMockRecorder struct {
	mock *MockTimerProcessor
}

// NewMockTimerProcessor creates a new mock instance.
func NewMockTimerProcessor(ctrl *gomock.Controller) *MockTimerProcessor {
	mock := &MockTimerProcessor{ctrl: ctrl}
	mock.recorder = &MockTimerProcessorMockRecorder{mock}
	return mock
}

// EXPECT returns an object that allows the caller to indicate expected use.
func (m *MockTimerProcessor) EXPECT() *MockTimerProcessorMockRecorder {
	return m.recorder
}

// AddTimers mocks base method.
func (m *MockTimerProcessor) AddTimers(stateExeId string, commands []iwfidl.TimerCommand, completedTimerCmds map[int]service.InternalTimerStatus) {
	m.ctrl.T.Helper()
	m.ctrl.Call(m, "AddTimers", stateExeId, commands, completedTimerCmds)
}

// AddTimers indicates an expected call of AddTimers.
func (mr *MockTimerProcessorMockRecorder) AddTimers(stateExeId, commands, completedTimerCmds interface{}) *gomock.Call {
	mr.mock.ctrl.T.Helper()
	return mr.mock.ctrl.RecordCallWithMethodType(mr.mock, "AddTimers", reflect.TypeOf((*MockTimerProcessor)(nil).AddTimers), stateExeId, commands, completedTimerCmds)
}

// Dump mocks base method.
func (m *MockTimerProcessor) Dump() []service.StaleSkipTimerSignal {
	m.ctrl.T.Helper()
	ret := m.ctrl.Call(m, "Dump")
	ret0, _ := ret[0].([]service.StaleSkipTimerSignal)
	return ret0
}

// Dump indicates an expected call of Dump.
func (mr *MockTimerProcessorMockRecorder) Dump() *gomock.Call {
	mr.mock.ctrl.T.Helper()
	return mr.mock.ctrl.RecordCallWithMethodType(mr.mock, "Dump", reflect.TypeOf((*MockTimerProcessor)(nil).Dump))
}

// GetTimerInfos mocks base method.
func (m *MockTimerProcessor) GetTimerInfos() map[string][]*service.TimerInfo {
	m.ctrl.T.Helper()
	ret := m.ctrl.Call(m, "GetTimerInfos")
	ret0, _ := ret[0].(map[string][]*service.TimerInfo)
	return ret0
}

// GetTimerInfos indicates an expected call of GetTimerInfos.
func (mr *MockTimerProcessorMockRecorder) GetTimerInfos() *gomock.Call {
	mr.mock.ctrl.T.Helper()
	return mr.mock.ctrl.RecordCallWithMethodType(mr.mock, "GetTimerInfos", reflect.TypeOf((*MockTimerProcessor)(nil).GetTimerInfos))
}

// GetTimerStartedUnixTimestamps mocks base method.
func (m *MockTimerProcessor) GetTimerStartedUnixTimestamps() []int64 {
	m.ctrl.T.Helper()
	ret := m.ctrl.Call(m, "GetTimerStartedUnixTimestamps")
	ret0, _ := ret[0].([]int64)
	return ret0
}

// GetTimerStartedUnixTimestamps indicates an expected call of GetTimerStartedUnixTimestamps.
func (mr *MockTimerProcessorMockRecorder) GetTimerStartedUnixTimestamps() *gomock.Call {
	mr.mock.ctrl.T.Helper()
	return mr.mock.ctrl.RecordCallWithMethodType(mr.mock, "GetTimerStartedUnixTimestamps", reflect.TypeOf((*MockTimerProcessor)(nil).GetTimerStartedUnixTimestamps))
}

// RemovePendingTimersOfState mocks base method.
func (m *MockTimerProcessor) RemovePendingTimersOfState(stateExeId string) {
	m.ctrl.T.Helper()
	m.ctrl.Call(m, "RemovePendingTimersOfState", stateExeId)
}

// RemovePendingTimersOfState indicates an expected call of RemovePendingTimersOfState.
func (mr *MockTimerProcessorMockRecorder) RemovePendingTimersOfState(stateExeId interface{}) *gomock.Call {
	mr.mock.ctrl.T.Helper()
	return mr.mock.ctrl.RecordCallWithMethodType(mr.mock, "RemovePendingTimersOfState", reflect.TypeOf((*MockTimerProcessor)(nil).RemovePendingTimersOfState), stateExeId)
}

// RetryStaleSkipTimer mocks base method.
func (m *MockTimerProcessor) RetryStaleSkipTimer() bool {
	m.ctrl.T.Helper()
	ret := m.ctrl.Call(m, "RetryStaleSkipTimer")
	ret0, _ := ret[0].(bool)
	return ret0
}

// RetryStaleSkipTimer indicates an expected call of RetryStaleSkipTimer.
func (mr *MockTimerProcessorMockRecorder) RetryStaleSkipTimer() *gomock.Call {
	mr.mock.ctrl.T.Helper()
	return mr.mock.ctrl.RecordCallWithMethodType(mr.mock, "RetryStaleSkipTimer", reflect.TypeOf((*MockTimerProcessor)(nil).RetryStaleSkipTimer))
}

// SkipTimer mocks base method.
func (m *MockTimerProcessor) SkipTimer(stateExeId, timerId string, timerIdx int) bool {
	m.ctrl.T.Helper()
	ret := m.ctrl.Call(m, "SkipTimer", stateExeId, timerId, timerIdx)
	ret0, _ := ret[0].(bool)
	return ret0
}

// SkipTimer indicates an expected call of SkipTimer.
func (mr *MockTimerProcessorMockRecorder) SkipTimer(stateExeId, timerId, timerIdx interface{}) *gomock.Call {
	mr.mock.ctrl.T.Helper()
	return mr.mock.ctrl.RecordCallWithMethodType(mr.mock, "SkipTimer", reflect.TypeOf((*MockTimerProcessor)(nil).SkipTimer), stateExeId, timerId, timerIdx)
}

// WaitForTimerFiredOrSkipped mocks base method.
func (m *MockTimerProcessor) WaitForTimerFiredOrSkipped(ctx UnifiedContext, stateExeId string, timerIdx int, cancelWaiting *bool) service.InternalTimerStatus {
	m.ctrl.T.Helper()
	ret := m.ctrl.Call(m, "WaitForTimerFiredOrSkipped", ctx, stateExeId, timerIdx, cancelWaiting)
	ret0, _ := ret[0].(service.InternalTimerStatus)
	return ret0
}

// WaitForTimerFiredOrSkipped indicates an expected call of WaitForTimerFiredOrSkipped.
func (mr *MockTimerProcessorMockRecorder) WaitForTimerFiredOrSkipped(ctx, stateExeId, timerIdx, cancelWaiting interface{}) *gomock.Call {
	mr.mock.ctrl.T.Helper()
	return mr.mock.ctrl.RecordCallWithMethodType(mr.mock, "WaitForTimerFiredOrSkipped", reflect.TypeOf((*MockTimerProcessor)(nil).WaitForTimerFiredOrSkipped), ctx, stateExeId, timerIdx, cancelWaiting)
}

// MockWorkflowProvider is a mock of WorkflowProvider interface.
type MockWorkflowProvider struct {
	ctrl     *gomock.Controller
	recorder *MockWorkflowProviderMockRecorder
}

// MockWorkflowProviderMockRecorder is the mock recorder for MockWorkflowProvider.
type MockWorkflowProviderMockRecorder struct {
	mock *MockWorkflowProvider
}

// NewMockWorkflowProvider creates a new mock instance.
func NewMockWorkflowProvider(ctrl *gomock.Controller) *MockWorkflowProvider {
	mock := &MockWorkflowProvider{ctrl: ctrl}
	mock.recorder = &MockWorkflowProviderMockRecorder{mock}
	return mock
}

// EXPECT returns an object that allows the caller to indicate expected use.
func (m *MockWorkflowProvider) EXPECT() *MockWorkflowProviderMockRecorder {
	return m.recorder
}

// Await mocks base method.
func (m *MockWorkflowProvider) Await(ctx UnifiedContext, condition func() bool) error {
	m.ctrl.T.Helper()
	ret := m.ctrl.Call(m, "Await", ctx, condition)
	ret0, _ := ret[0].(error)
	return ret0
}

// Await indicates an expected call of Await.
func (mr *MockWorkflowProviderMockRecorder) Await(ctx, condition interface{}) *gomock.Call {
	mr.mock.ctrl.T.Helper()
	return mr.mock.ctrl.RecordCallWithMethodType(mr.mock, "Await", reflect.TypeOf((*MockWorkflowProvider)(nil).Await), ctx, condition)
}

// ExecuteActivity mocks base method.
func (m *MockWorkflowProvider) ExecuteActivity(valuePtr interface{}, optimizeByLocalActivity bool, ctx UnifiedContext, activity interface{}, args ...interface{}) error {
	m.ctrl.T.Helper()
	varargs := []interface{}{valuePtr, optimizeByLocalActivity, ctx, activity}
	for _, a := range args {
		varargs = append(varargs, a)
	}
	ret := m.ctrl.Call(m, "ExecuteActivity", varargs...)
	ret0, _ := ret[0].(error)
	return ret0
}

// ExecuteActivity indicates an expected call of ExecuteActivity.
func (mr *MockWorkflowProviderMockRecorder) ExecuteActivity(valuePtr, optimizeByLocalActivity, ctx, activity interface{}, args ...interface{}) *gomock.Call {
	mr.mock.ctrl.T.Helper()
	varargs := append([]interface{}{valuePtr, optimizeByLocalActivity, ctx, activity}, args...)
	return mr.mock.ctrl.RecordCallWithMethodType(mr.mock, "ExecuteActivity", reflect.TypeOf((*MockWorkflowProvider)(nil).ExecuteActivity), varargs...)
}

// ExecuteLocalActivity mocks base method.
func (m *MockWorkflowProvider) ExecuteLocalActivity(valuePtr interface{}, ctx UnifiedContext, activity interface{}, args ...interface{}) error {
	m.ctrl.T.Helper()
	varargs := []interface{}{valuePtr, ctx, activity}
	for _, a := range args {
		varargs = append(varargs, a)
	}
	ret := m.ctrl.Call(m, "ExecuteLocalActivity", varargs...)
	ret0, _ := ret[0].(error)
	return ret0
}

// ExecuteLocalActivity indicates an expected call of ExecuteLocalActivity.
func (mr *MockWorkflowProviderMockRecorder) ExecuteLocalActivity(valuePtr, ctx, activity interface{}, args ...interface{}) *gomock.Call {
	mr.mock.ctrl.T.Helper()
	varargs := append([]interface{}{valuePtr, ctx, activity}, args...)
	return mr.mock.ctrl.RecordCallWithMethodType(mr.mock, "ExecuteLocalActivity", reflect.TypeOf((*MockWorkflowProvider)(nil).ExecuteLocalActivity), varargs...)
}

// ExtendContextWithValue mocks base method.
func (m *MockWorkflowProvider) ExtendContextWithValue(parent UnifiedContext, key string, val interface{}) UnifiedContext {
	m.ctrl.T.Helper()
	ret := m.ctrl.Call(m, "ExtendContextWithValue", parent, key, val)
	ret0, _ := ret[0].(UnifiedContext)
	return ret0
}

// ExtendContextWithValue indicates an expected call of ExtendContextWithValue.
func (mr *MockWorkflowProviderMockRecorder) ExtendContextWithValue(parent, key, val interface{}) *gomock.Call {
	mr.mock.ctrl.T.Helper()
	return mr.mock.ctrl.RecordCallWithMethodType(mr.mock, "ExtendContextWithValue", reflect.TypeOf((*MockWorkflowProvider)(nil).ExtendContextWithValue), parent, key, val)
}

// GetBackendType mocks base method.
func (m *MockWorkflowProvider) GetBackendType() service.BackendType {
	m.ctrl.T.Helper()
	ret := m.ctrl.Call(m, "GetBackendType")
	ret0, _ := ret[0].(service.BackendType)
	return ret0
}

// GetBackendType indicates an expected call of GetBackendType.
func (mr *MockWorkflowProviderMockRecorder) GetBackendType() *gomock.Call {
	mr.mock.ctrl.T.Helper()
	return mr.mock.ctrl.RecordCallWithMethodType(mr.mock, "GetBackendType", reflect.TypeOf((*MockWorkflowProvider)(nil).GetBackendType))
}

// GetContextValue mocks base method.
func (m *MockWorkflowProvider) GetContextValue(ctx UnifiedContext, key string) interface{} {
	m.ctrl.T.Helper()
	ret := m.ctrl.Call(m, "GetContextValue", ctx, key)
	ret0, _ := ret[0].(interface{})
	return ret0
}

// GetContextValue indicates an expected call of GetContextValue.
func (mr *MockWorkflowProviderMockRecorder) GetContextValue(ctx, key interface{}) *gomock.Call {
	mr.mock.ctrl.T.Helper()
	return mr.mock.ctrl.RecordCallWithMethodType(mr.mock, "GetContextValue", reflect.TypeOf((*MockWorkflowProvider)(nil).GetContextValue), ctx, key)
}

// GetLogger mocks base method.
func (m *MockWorkflowProvider) GetLogger(ctx UnifiedContext) UnifiedLogger {
	m.ctrl.T.Helper()
	ret := m.ctrl.Call(m, "GetLogger", ctx)
	ret0, _ := ret[0].(UnifiedLogger)
	return ret0
}

// GetLogger indicates an expected call of GetLogger.
func (mr *MockWorkflowProviderMockRecorder) GetLogger(ctx interface{}) *gomock.Call {
	mr.mock.ctrl.T.Helper()
	return mr.mock.ctrl.RecordCallWithMethodType(mr.mock, "GetLogger", reflect.TypeOf((*MockWorkflowProvider)(nil).GetLogger), ctx)
}

// GetPendingThreadNames mocks base method.
func (m *MockWorkflowProvider) GetPendingThreadNames() map[string]int {
	m.ctrl.T.Helper()
	ret := m.ctrl.Call(m, "GetPendingThreadNames")
	ret0, _ := ret[0].(map[string]int)
	return ret0
}

// GetPendingThreadNames indicates an expected call of GetPendingThreadNames.
func (mr *MockWorkflowProviderMockRecorder) GetPendingThreadNames() *gomock.Call {
	mr.mock.ctrl.T.Helper()
	return mr.mock.ctrl.RecordCallWithMethodType(mr.mock, "GetPendingThreadNames", reflect.TypeOf((*MockWorkflowProvider)(nil).GetPendingThreadNames))
}

// GetSearchAttributes mocks base method.
func (m *MockWorkflowProvider) GetSearchAttributes(ctx UnifiedContext, requestedSearchAttributes []iwfidl.SearchAttributeKeyAndType) (map[string]iwfidl.SearchAttribute, error) {
	m.ctrl.T.Helper()
	ret := m.ctrl.Call(m, "GetSearchAttributes", ctx, requestedSearchAttributes)
	ret0, _ := ret[0].(map[string]iwfidl.SearchAttribute)
	ret1, _ := ret[1].(error)
	return ret0, ret1
}

// GetSearchAttributes indicates an expected call of GetSearchAttributes.
func (mr *MockWorkflowProviderMockRecorder) GetSearchAttributes(ctx, requestedSearchAttributes interface{}) *gomock.Call {
	mr.mock.ctrl.T.Helper()
	return mr.mock.ctrl.RecordCallWithMethodType(mr.mock, "GetSearchAttributes", reflect.TypeOf((*MockWorkflowProvider)(nil).GetSearchAttributes), ctx, requestedSearchAttributes)
}

// GetSignalChannel mocks base method.
func (m *MockWorkflowProvider) GetSignalChannel(ctx UnifiedContext, signalName string) ReceiveChannel {
	m.ctrl.T.Helper()
	ret := m.ctrl.Call(m, "GetSignalChannel", ctx, signalName)
	ret0, _ := ret[0].(ReceiveChannel)
	return ret0
}

// GetSignalChannel indicates an expected call of GetSignalChannel.
func (mr *MockWorkflowProviderMockRecorder) GetSignalChannel(ctx, signalName interface{}) *gomock.Call {
	mr.mock.ctrl.T.Helper()
	return mr.mock.ctrl.RecordCallWithMethodType(mr.mock, "GetSignalChannel", reflect.TypeOf((*MockWorkflowProvider)(nil).GetSignalChannel), ctx, signalName)
}

// GetThreadCount mocks base method.
func (m *MockWorkflowProvider) GetThreadCount() int {
	m.ctrl.T.Helper()
	ret := m.ctrl.Call(m, "GetThreadCount")
	ret0, _ := ret[0].(int)
	return ret0
}

// GetThreadCount indicates an expected call of GetThreadCount.
func (mr *MockWorkflowProviderMockRecorder) GetThreadCount() *gomock.Call {
	mr.mock.ctrl.T.Helper()
	return mr.mock.ctrl.RecordCallWithMethodType(mr.mock, "GetThreadCount", reflect.TypeOf((*MockWorkflowProvider)(nil).GetThreadCount))
}

// GetUnhandledSignalNames mocks base method.
func (m *MockWorkflowProvider) GetUnhandledSignalNames(ctx UnifiedContext) []string {
	m.ctrl.T.Helper()
	ret := m.ctrl.Call(m, "GetUnhandledSignalNames", ctx)
	ret0, _ := ret[0].([]string)
	return ret0
}

// GetUnhandledSignalNames indicates an expected call of GetUnhandledSignalNames.
func (mr *MockWorkflowProviderMockRecorder) GetUnhandledSignalNames(ctx interface{}) *gomock.Call {
	mr.mock.ctrl.T.Helper()
	return mr.mock.ctrl.RecordCallWithMethodType(mr.mock, "GetUnhandledSignalNames", reflect.TypeOf((*MockWorkflowProvider)(nil).GetUnhandledSignalNames), ctx)
}

// GetVersion mocks base method.
func (m *MockWorkflowProvider) GetVersion(ctx UnifiedContext, changeID string, minSupported, maxSupported int) int {
	m.ctrl.T.Helper()
	ret := m.ctrl.Call(m, "GetVersion", ctx, changeID, minSupported, maxSupported)
	ret0, _ := ret[0].(int)
	return ret0
}

// GetVersion indicates an expected call of GetVersion.
func (mr *MockWorkflowProviderMockRecorder) GetVersion(ctx, changeID, minSupported, maxSupported interface{}) *gomock.Call {
	mr.mock.ctrl.T.Helper()
	return mr.mock.ctrl.RecordCallWithMethodType(mr.mock, "GetVersion", reflect.TypeOf((*MockWorkflowProvider)(nil).GetVersion), ctx, changeID, minSupported, maxSupported)
}

// GetWorkflowInfo mocks base method.
func (m *MockWorkflowProvider) GetWorkflowInfo(ctx UnifiedContext) WorkflowInfo {
	m.ctrl.T.Helper()
	ret := m.ctrl.Call(m, "GetWorkflowInfo", ctx)
	ret0, _ := ret[0].(WorkflowInfo)
	return ret0
}

// GetWorkflowInfo indicates an expected call of GetWorkflowInfo.
func (mr *MockWorkflowProviderMockRecorder) GetWorkflowInfo(ctx interface{}) *gomock.Call {
	mr.mock.ctrl.T.Helper()
	return mr.mock.ctrl.RecordCallWithMethodType(mr.mock, "GetWorkflowInfo", reflect.TypeOf((*MockWorkflowProvider)(nil).GetWorkflowInfo), ctx)
}

// GoNamed mocks base method.
func (m *MockWorkflowProvider) GoNamed(ctx UnifiedContext, name string, f func(UnifiedContext)) {
	m.ctrl.T.Helper()
	m.ctrl.Call(m, "GoNamed", ctx, name, f)
}

// GoNamed indicates an expected call of GoNamed.
func (mr *MockWorkflowProviderMockRecorder) GoNamed(ctx, name, f interface{}) *gomock.Call {
	mr.mock.ctrl.T.Helper()
	return mr.mock.ctrl.RecordCallWithMethodType(mr.mock, "GoNamed", reflect.TypeOf((*MockWorkflowProvider)(nil).GoNamed), ctx, name, f)
}

// IsApplicationError mocks base method.
func (m *MockWorkflowProvider) IsApplicationError(err error) bool {
	m.ctrl.T.Helper()
	ret := m.ctrl.Call(m, "IsApplicationError", err)
	ret0, _ := ret[0].(bool)
	return ret0
}

// IsApplicationError indicates an expected call of IsApplicationError.
func (mr *MockWorkflowProviderMockRecorder) IsApplicationError(err interface{}) *gomock.Call {
	mr.mock.ctrl.T.Helper()
	return mr.mock.ctrl.RecordCallWithMethodType(mr.mock, "IsApplicationError", reflect.TypeOf((*MockWorkflowProvider)(nil).IsApplicationError), err)
}

// IsReplaying mocks base method.
func (m *MockWorkflowProvider) IsReplaying(ctx UnifiedContext) bool {
	m.ctrl.T.Helper()
	ret := m.ctrl.Call(m, "IsReplaying", ctx)
	ret0, _ := ret[0].(bool)
	return ret0
}

// IsReplaying indicates an expected call of IsReplaying.
func (mr *MockWorkflowProviderMockRecorder) IsReplaying(ctx interface{}) *gomock.Call {
	mr.mock.ctrl.T.Helper()
	return mr.mock.ctrl.RecordCallWithMethodType(mr.mock, "IsReplaying", reflect.TypeOf((*MockWorkflowProvider)(nil).IsReplaying), ctx)
}

// NewApplicationError mocks base method.
func (m *MockWorkflowProvider) NewApplicationError(errType string, details interface{}) error {
	m.ctrl.T.Helper()
	ret := m.ctrl.Call(m, "NewApplicationError", errType, details)
	ret0, _ := ret[0].(error)
	return ret0
}

// NewApplicationError indicates an expected call of NewApplicationError.
func (mr *MockWorkflowProviderMockRecorder) NewApplicationError(errType, details interface{}) *gomock.Call {
	mr.mock.ctrl.T.Helper()
	return mr.mock.ctrl.RecordCallWithMethodType(mr.mock, "NewApplicationError", reflect.TypeOf((*MockWorkflowProvider)(nil).NewApplicationError), errType, details)
}

// NewInterpreterContinueAsNewError mocks base method.
func (m *MockWorkflowProvider) NewInterpreterContinueAsNewError(ctx UnifiedContext, input service.InterpreterWorkflowInput) error {
	m.ctrl.T.Helper()
	ret := m.ctrl.Call(m, "NewInterpreterContinueAsNewError", ctx, input)
	ret0, _ := ret[0].(error)
	return ret0
}

// NewInterpreterContinueAsNewError indicates an expected call of NewInterpreterContinueAsNewError.
func (mr *MockWorkflowProviderMockRecorder) NewInterpreterContinueAsNewError(ctx, input interface{}) *gomock.Call {
	mr.mock.ctrl.T.Helper()
	return mr.mock.ctrl.RecordCallWithMethodType(mr.mock, "NewInterpreterContinueAsNewError", reflect.TypeOf((*MockWorkflowProvider)(nil).NewInterpreterContinueAsNewError), ctx, input)
}

// NewTimer mocks base method.
func (m *MockWorkflowProvider) NewTimer(ctx UnifiedContext, d time.Duration) Future {
	m.ctrl.T.Helper()
	ret := m.ctrl.Call(m, "NewTimer", ctx, d)
	ret0, _ := ret[0].(Future)
	return ret0
}

// NewTimer indicates an expected call of NewTimer.
func (mr *MockWorkflowProviderMockRecorder) NewTimer(ctx, d interface{}) *gomock.Call {
	mr.mock.ctrl.T.Helper()
	return mr.mock.ctrl.RecordCallWithMethodType(mr.mock, "NewTimer", reflect.TypeOf((*MockWorkflowProvider)(nil).NewTimer), ctx, d)
}

// Now mocks base method.
func (m *MockWorkflowProvider) Now(ctx UnifiedContext) time.Time {
	m.ctrl.T.Helper()
	ret := m.ctrl.Call(m, "Now", ctx)
	ret0, _ := ret[0].(time.Time)
	return ret0
}

// Now indicates an expected call of Now.
func (mr *MockWorkflowProviderMockRecorder) Now(ctx interface{}) *gomock.Call {
	mr.mock.ctrl.T.Helper()
	return mr.mock.ctrl.RecordCallWithMethodType(mr.mock, "Now", reflect.TypeOf((*MockWorkflowProvider)(nil).Now), ctx)
}

// SetQueryHandler mocks base method.
func (m *MockWorkflowProvider) SetQueryHandler(ctx UnifiedContext, queryType string, handler interface{}) error {
	m.ctrl.T.Helper()
	ret := m.ctrl.Call(m, "SetQueryHandler", ctx, queryType, handler)
	ret0, _ := ret[0].(error)
	return ret0
}

// SetQueryHandler indicates an expected call of SetQueryHandler.
func (mr *MockWorkflowProviderMockRecorder) SetQueryHandler(ctx, queryType, handler interface{}) *gomock.Call {
	mr.mock.ctrl.T.Helper()
	return mr.mock.ctrl.RecordCallWithMethodType(mr.mock, "SetQueryHandler", reflect.TypeOf((*MockWorkflowProvider)(nil).SetQueryHandler), ctx, queryType, handler)
}

// SetRpcUpdateHandler mocks base method.
func (m *MockWorkflowProvider) SetRpcUpdateHandler(ctx UnifiedContext, updateType string, validator UnifiedRpcValidator, handler UnifiedRpcHandler) error {
	m.ctrl.T.Helper()
	ret := m.ctrl.Call(m, "SetRpcUpdateHandler", ctx, updateType, validator, handler)
	ret0, _ := ret[0].(error)
	return ret0
}

// SetRpcUpdateHandler indicates an expected call of SetRpcUpdateHandler.
func (mr *MockWorkflowProviderMockRecorder) SetRpcUpdateHandler(ctx, updateType, validator, handler interface{}) *gomock.Call {
	mr.mock.ctrl.T.Helper()
	return mr.mock.ctrl.RecordCallWithMethodType(mr.mock, "SetRpcUpdateHandler", reflect.TypeOf((*MockWorkflowProvider)(nil).SetRpcUpdateHandler), ctx, updateType, validator, handler)
}

// Sleep mocks base method.
func (m *MockWorkflowProvider) Sleep(ctx UnifiedContext, d time.Duration) error {
	m.ctrl.T.Helper()
	ret := m.ctrl.Call(m, "Sleep", ctx, d)
	ret0, _ := ret[0].(error)
	return ret0
}

// Sleep indicates an expected call of Sleep.
func (mr *MockWorkflowProviderMockRecorder) Sleep(ctx, d interface{}) *gomock.Call {
	mr.mock.ctrl.T.Helper()
	return mr.mock.ctrl.RecordCallWithMethodType(mr.mock, "Sleep", reflect.TypeOf((*MockWorkflowProvider)(nil).Sleep), ctx, d)
}

// UpsertMemo mocks base method.
func (m *MockWorkflowProvider) UpsertMemo(ctx UnifiedContext, memo map[string]iwfidl.EncodedObject) error {
	m.ctrl.T.Helper()
	ret := m.ctrl.Call(m, "UpsertMemo", ctx, memo)
	ret0, _ := ret[0].(error)
	return ret0
}

// UpsertMemo indicates an expected call of UpsertMemo.
func (mr *MockWorkflowProviderMockRecorder) UpsertMemo(ctx, memo interface{}) *gomock.Call {
	mr.mock.ctrl.T.Helper()
	return mr.mock.ctrl.RecordCallWithMethodType(mr.mock, "UpsertMemo", reflect.TypeOf((*MockWorkflowProvider)(nil).UpsertMemo), ctx, memo)
}

// UpsertSearchAttributes mocks base method.
func (m *MockWorkflowProvider) UpsertSearchAttributes(ctx UnifiedContext, attributes map[string]interface{}) error {
	m.ctrl.T.Helper()
	ret := m.ctrl.Call(m, "UpsertSearchAttributes", ctx, attributes)
	ret0, _ := ret[0].(error)
	return ret0
}

// UpsertSearchAttributes indicates an expected call of UpsertSearchAttributes.
func (mr *MockWorkflowProviderMockRecorder) UpsertSearchAttributes(ctx, attributes interface{}) *gomock.Call {
	mr.mock.ctrl.T.Helper()
	return mr.mock.ctrl.RecordCallWithMethodType(mr.mock, "UpsertSearchAttributes", reflect.TypeOf((*MockWorkflowProvider)(nil).UpsertSearchAttributes), ctx, attributes)
}

// WithActivityOptions mocks base method.
func (m *MockWorkflowProvider) WithActivityOptions(ctx UnifiedContext, options ActivityOptions) UnifiedContext {
	m.ctrl.T.Helper()
	ret := m.ctrl.Call(m, "WithActivityOptions", ctx, options)
	ret0, _ := ret[0].(UnifiedContext)
	return ret0
}

// WithActivityOptions indicates an expected call of WithActivityOptions.
func (mr *MockWorkflowProviderMockRecorder) WithActivityOptions(ctx, options interface{}) *gomock.Call {
	mr.mock.ctrl.T.Helper()
	return mr.mock.ctrl.RecordCallWithMethodType(mr.mock, "WithActivityOptions", reflect.TypeOf((*MockWorkflowProvider)(nil).WithActivityOptions), ctx, options)
}

// MockReceiveChannel is a mock of ReceiveChannel interface.
type MockReceiveChannel struct {
	ctrl     *gomock.Controller
	recorder *MockReceiveChannelMockRecorder
}

// MockReceiveChannelMockRecorder is the mock recorder for MockReceiveChannel.
type MockReceiveChannelMockRecorder struct {
	mock *MockReceiveChannel
}

// NewMockReceiveChannel creates a new mock instance.
func NewMockReceiveChannel(ctrl *gomock.Controller) *MockReceiveChannel {
	mock := &MockReceiveChannel{ctrl: ctrl}
	mock.recorder = &MockReceiveChannelMockRecorder{mock}
	return mock
}

// EXPECT returns an object that allows the caller to indicate expected use.
func (m *MockReceiveChannel) EXPECT() *MockReceiveChannelMockRecorder {
	return m.recorder
}

// ReceiveAsync mocks base method.
func (m *MockReceiveChannel) ReceiveAsync(valuePtr interface{}) bool {
	m.ctrl.T.Helper()
	ret := m.ctrl.Call(m, "ReceiveAsync", valuePtr)
	ret0, _ := ret[0].(bool)
	return ret0
}

// ReceiveAsync indicates an expected call of ReceiveAsync.
func (mr *MockReceiveChannelMockRecorder) ReceiveAsync(valuePtr interface{}) *gomock.Call {
	mr.mock.ctrl.T.Helper()
	return mr.mock.ctrl.RecordCallWithMethodType(mr.mock, "ReceiveAsync", reflect.TypeOf((*MockReceiveChannel)(nil).ReceiveAsync), valuePtr)
}

// ReceiveBlocking mocks base method.
func (m *MockReceiveChannel) ReceiveBlocking(ctx UnifiedContext, valuePtr interface{}) bool {
	m.ctrl.T.Helper()
	ret := m.ctrl.Call(m, "ReceiveBlocking", ctx, valuePtr)
	ret0, _ := ret[0].(bool)
	return ret0
}

// ReceiveBlocking indicates an expected call of ReceiveBlocking.
func (mr *MockReceiveChannelMockRecorder) ReceiveBlocking(ctx, valuePtr interface{}) *gomock.Call {
	mr.mock.ctrl.T.Helper()
	return mr.mock.ctrl.RecordCallWithMethodType(mr.mock, "ReceiveBlocking", reflect.TypeOf((*MockReceiveChannel)(nil).ReceiveBlocking), ctx, valuePtr)
}

// MockFuture is a mock of Future interface.
type MockFuture struct {
	ctrl     *gomock.Controller
	recorder *MockFutureMockRecorder
}

// MockFutureMockRecorder is the mock recorder for MockFuture.
type MockFutureMockRecorder struct {
	mock *MockFuture
}

// NewMockFuture creates a new mock instance.
func NewMockFuture(ctrl *gomock.Controller) *MockFuture {
	mock := &MockFuture{ctrl: ctrl}
	mock.recorder = &MockFutureMockRecorder{mock}
	return mock
}

// EXPECT returns an object that allows the caller to indicate expected use.
func (m *MockFuture) EXPECT() *MockFutureMockRecorder {
	return m.recorder
}

// Get mocks base method.
func (m *MockFuture) Get(ctx UnifiedContext, valuePtr interface{}) error {
	m.ctrl.T.Helper()
	ret := m.ctrl.Call(m, "Get", ctx, valuePtr)
	ret0, _ := ret[0].(error)
	return ret0
}

// Get indicates an expected call of Get.
func (mr *MockFutureMockRecorder) Get(ctx, valuePtr interface{}) *gomock.Call {
	mr.mock.ctrl.T.Helper()
	return mr.mock.ctrl.RecordCallWithMethodType(mr.mock, "Get", reflect.TypeOf((*MockFuture)(nil).Get), ctx, valuePtr)
}

// IsReady mocks base method.
func (m *MockFuture) IsReady() bool {
	m.ctrl.T.Helper()
	ret := m.ctrl.Call(m, "IsReady")
	ret0, _ := ret[0].(bool)
	return ret0
}

// IsReady indicates an expected call of IsReady.
func (mr *MockFutureMockRecorder) IsReady() *gomock.Call {
	mr.mock.ctrl.T.Helper()
	return mr.mock.ctrl.RecordCallWithMethodType(mr.mock, "IsReady", reflect.TypeOf((*MockFuture)(nil).IsReady))
}
